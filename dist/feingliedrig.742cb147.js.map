{"mappings":"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","sources":["js/split.js"],"sourcesContent":["(function() {\n    function lerp(current, target, speed = 0.1, limit = 0.001) {\n        let change = (target - current) * speed;\n        if (Math.abs(change) < limit) {\n            change = target - current;\n        }\n        return change;\n    }\n\n    const baseContent = document.getElementById(\"base-content\");\n\n    const foldWrapper = document.getElementById(\"fold-wrapper\");\n\n    const btn = document.getElementById(\"btn-debug\");\n    const toggleDebug = () => {\n        document.body.classList.toggle(\"debug\");\n    };\n    btn.addEventListener(\"click\", toggleDebug);\n\n    let state = {\n        scroll: 0,\n        targetScroll: 0,\n        progress: 0,\n        targetProgress: 0,\n        disposed: false\n    };\n    // The folds can be either pre-generated or Folded dom can generate them for you.\n    class FoldedDom {\n        constructor(wrapper, folds = null) {\n            this.wrapper = wrapper;\n            this.folds = folds;\n            this.centerHeight = 0;\n        }\n        createFold(side = \"center\", index = 0) {\n            const fold = document.createElement(\"div\");\n            fold.classList.add(\"fold\");\n            switch (side) {\n                case \"before\":\n                    fold.classList.add(\"fold-before\");\n                    fold.classList.add(\"fold-before-\" + index);\n                    break;\n                case \"after\":\n                    fold.classList.add(\"fold-after\");\n                    fold.classList.add(\"fold-after-\" + index);\n                    break;\n                default:\n                    fold.classList.add(\"fold-middle\");\n                    break;\n            }\n\n            const content = this.baseContent.cloneNode(true);\n\n            content.classList.remove(\"base-content\");\n            content.id = \"\";\n\n            const scroller = document.createElement(\"div\");\n            scroller.classList.add(\"fold-scroller\");\n            scroller.append(content);\n\n            fold.append(scroller);\n\n            return fold;\n        }\n        generateSide(baseContent, foldCount, side) {\n            const centerFold = this.createFold(0, 0);\n\n            const beforeFolds = [];\n            const afterFolds = [];\n            for (let i = 0; i < foldCount; i++) {\n                beforeFolds.push(this.createFold(\"before\", i + 1));\n                afterFolds.push(this.createFold(\"after\", i + 1));\n            }\n\n            // Reverse to pace index 0 next to the center element\n            let folds = beforeFolds\n                .reverse()\n                .concat(centerFold)\n                .concat(afterFolds);\n            const foldedDomEle = document.createElement(\"div\");\n            foldedDomEle.classList.add(\"wrapper-3d\");\n            foldedDomEle.classList.add(\"side-\" + side);\n            folds.forEach(fold => {\n                foldedDomEle.append(fold);\n            });\n            this.wrapper.append(foldedDomEle);\n\n            return { folds, wrapper: foldedDomEle };\n        }\n        generateFolds(baseContent, foldCount) {\n            this.baseContent = baseContent;\n\n            const leftFolds = this.generateSide(baseContent, 1, \"left\");\n            const rightFolds = this.generateSide(baseContent, 1, \"right\");\n\n            this.centerFold =\n                rightFolds.folds[Math.floor(leftFolds.folds.length / 2)];\n\n            this.leftFolds = leftFolds;\n            this.rightFolds = rightFolds;\n            // return folds;\n        }\n        updateStyles(progress) {\n            let leftFolds = this.leftFolds.folds;\n            let rightFolds = this.rightFolds.folds;\n            let center = Math.floor(leftFolds.length / 2);\n            let scroll = center * -100;\n\n            for (let i = 0; i < leftFolds.length; i++) {\n                let foldLeft = leftFolds[i];\n                let foldRight = rightFolds[i];\n                const centerRelativeIndex = i - center;\n                let percentage = `${scroll - centerRelativeIndex * 100 + 100}%`;\n                let pixels = 0;\n                let translateY = percentage;\n                // The top folds are easy to sync because we only need to move them by 100% of the folds\n                if (centerRelativeIndex > 0) {\n                    // The bottom folds, start at some place in the center(exactly height of middle folds).\n                    // So to sync it up it needs to use pixels of the content instead.\n                    pixels += -this.centerFold.offsetHeight;\n                    translateY = `${pixels}px`;\n                }\n                foldLeft.children[0].style.transform = `translateY(${translateY})`;\n                foldLeft.children[0].children[0].style.transform = `translateY(${progress}px)`;\n                foldRight.children[0].style.transform = `translate(-50%, ${translateY})`;\n                foldRight.children[0].children[0].style.transform = `translateY(${progress}px)`;\n            }\n        }\n    }\n\n    // We want the scroll to be inside the middle fold.\n    // So it needs to be height of screen + the height of the content - minus the height of the fold.\n    // This makes it so we only create a scrollbar if the content is bigger than the middle fold.\n    let foldedDomCenter;\n    let tick = () => {\n        if (state.disposed) return;\n        document.body.style.height =\n            foldedDomCenter.centerFold.children[0].children[0].clientHeight +\n            -foldedDomCenter.centerFold.clientHeight +\n            window.innerHeight +\n            \"px\";\n\n        state.targetScroll = -(\n            document.documentElement.scrollTop || document.body.scrollTop\n        );\n\n        state.scroll += lerp(state.scroll, state.targetScroll, 0.1, 0.0001);\n\n        let progress = state.scroll;\n        foldedDomCenter.updateStyles(progress + baseContent.offsetTop);\n\n        requestAnimationFrame(tick);\n    };\n\n    /***********************************/\n    /********** Preload stuff **********/\n\n    // Preload images\n    const preloadImages = () => {\n        return new Promise((resolve, reject) => {\n            return resolve();\n        });\n    };\n\n    // And then..\n    preloadImages().then(() => {\n        // Remove the loader\n        document.body.classList.remove('loading');\n        // INITIALIZE\n        foldedDomCenter = new FoldedDom(foldWrapper);\n        const foldCount = 1;\n        foldedDomCenter.generateFolds(baseContent, foldCount);\n        tick();\n    });\n})();"],"names":["baseContent1","document","getElementById","foldWrapper","addEventListener","body","classList","toggle","foldedDomCenter","state","scroll","targetScroll","progress","targetProgress","disposed","FoldedDom","wrapper","folds","this","centerHeight","createFold","side","index","fold","createElement","add","content","baseContent","cloneNode","remove","id","scroller","append","generateSide","foldCount","centerFold","beforeFolds","afterFolds","i","push","reverse","concat","foldedDomEle","forEach","generateFolds","leftFolds","rightFolds","Math","floor","length","updateStyles","center","foldLeft","foldRight","centerRelativeIndex","pixels","translateY","offsetHeight","children","style","transform","tick","height","clientHeight","window","innerHeight","documentElement","scrollTop","current","target","speed","limit","change","abs","lerp","offsetTop","requestAnimationFrame","Promise","resolve","reject","then"],"version":3,"file":"feingliedrig.742cb147.js.map"}